---
layout:     post
title:      一种降低代码耦合度的方法
subtitle:   骚操作了解一下？
date:       2020-02-22
author:     Hehesheng
header-img: img/72722834.jpg
catalog: true
tags:
    - k210
    - 单片机
    - MCU
    - rt-thread
    - risc-v
	- linkscript
---
## 一种降低代码耦合度的方法

### 运行环境

- MAIX-GO （K210双核400M单片机）
- [rt-thread 4.0.3](https://github.com/RT-Thread/rt-thread)
- eclipse GNU
- [lvgl](https://littlevgl.com/)

### 耦合度

写代码时除了保证功能正常，也都会注意一下代码质量，而其中一个容易被提及的一个质量要求，代码的耦合度。

那么什么叫做代码的耦合度呢？

一般的说法就是模块之间互相的关联程度的度量标准，举个例子，比如A文件中有个变量value，然后B文件用到了这个变量，那么就说A和B文件之间存在耦合。

什么是高耦合度的代码呢？还是上面的例子，假设B文件有个函数func，这个函数被A中的代码调用了，那么我们就发现，AB两文件之间耦合度很高，因为他们互相关联。这样的代码看起来会非常混乱。

低耦合的代码一般来说都是高质量代码的代名词，好处就是维护简单，结构清晰。我不记得从哪听来的一句话：**低耦合的代码是就算你把代码中的几个文件删去，不管warning，你的代码能够编译通过，那么你的代码其实就耦合度很低了。**

上面的说法听起来有点神奇，以写C为例，我们经常编写函数用的方法就是一个.c和一个.h，然后再逻辑代码中包含.h，这种方法在你删去.h的时候，编译器100%会报错，找不到你包含的头文件。

的确，写一个.h文件出函数这种方法在很多时候非常简单也很好用。因为大家都能理解，但是正如耦合度定义的一样，这样文件之间的关联就过大了，换句话就是，耦合度高。

### 起因

想起耦合度的相关话题，也是我最近在玩开源图形库[lvgl](https://littlevgl.com/)时产生的。我的想法就是将功能一个个列在一个列表里，但是在我编写第二个功能的实现函数时，我就感觉到了一丝不对。

![](https://raw.githubusercontent.com/Hehesheng/blog_img/master/2020/02/16/184312.png)

一开始以模块化思想，一个功能通过调用一个函数去实现。那么问题就出现了，如果每增加一个功能，就扩一个头文件，下方也用个数组去绑定事件，显然，对于这个文件，他的耦合度就会增高。

这里的效果应该是像一个个app一样，互相隔离，能不能做到呢？

我就想到了在rt-thread中广泛使用的一种方式，自动化启动流程，以及其finsh指令的导出方式，utest的tc导出方式：**自定义段**

### 自定义段

我们知道，程序里有各种段，代码段，数据段等等，这些一般是约定俗成的。基本上所有程序都会有，但是这些段也是可以自行定义的。这就是链接脚本：**link script**。

这里利用这个特性，我们对我们的代码进行一些精细化定制。基本原理就是定义一些固定变量，将他们固定在我们设定的自定义段上，然后我们在程序中读出这些变量。

以大家熟知的stm32为例。

不同编译器有自己的链接脚本，这是keil的：

```asm
LR_IROM1 0x08000000 0x00100000  {    ; load region size_region
  ER_IROM1 0x08000000 0x00100000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$$Sections)
   .ANY (+RO)
  }
  RW_IRAM1 0x20000000 0x00030000  {  ; RW data
   .ANY (+RW +ZI)
  }
}
```

而这是gcc的（省略部分）：

```asm
/* Program Entry, set to mark it as "used" and avoid gc */
MEMORY
{
    CODE (rx) : ORIGIN = 0x08000000, LENGTH = 2048k /* 2048KB flash */
    RAM1 (rw) : ORIGIN = 0x20000000, LENGTH =  192k /* 192K sram */
    RAM2 (rw) : ORIGIN = 0x10000000, LENGTH =   64k /* 64K sram */
}
ENTRY(Reset_Handler)
_system_stack_size = 0x400;

SECTIONS
{
    .text :
    {
        . = ALIGN(4);
        _stext = .;
        KEEP(*(.isr_vector))            /* Startup code */

        . = ALIGN(4);
        *(.text)                        /* remaining code */
        *(.text.*)                      /* remaining code */
        *(.rodata)                      /* read-only data (constants) */
        *(.rodata*)
        *(.glue_7)
        *(.glue_7t)
        *(.gnu.linkonce.t*)
        ...
        ...
}
```

一般情况下，我们都不需要自己编辑链接脚本，所以在keil中，这个功能也被隐藏，它会按照默认值配置，所以这里我们要将他打开：

<img src="https://gitee.com/Hehesheng/blog_img/raw/master/2020/02/23/000650.png" style="zoom: 67%;" />

然后就要修改一下链接脚本文件，在text段添加以下内容，以gcc为例：

```asm
/* section information for lvgl apps */
. = ALIGN(8);
__lvgl_apps_tab_start = .;
KEEP(*(LVObjTab))
__lvgl_apps_tab_end = .;
. = ALIGN(8);
```

这六行，第一行是注释，第二和第六行是表示按照8字节对齐，中间的三行就是精髓了。这里是分别定义了\_\_lvgl_apps_tab_start、\_\_lvgl_apps_tab_end两个变量，中间创建名叫**LVObjTab**的自定义段。

### 代码导出到段

光有这个段还不够，我们还需要精确控制我们的变量能够落在这个段中。

这里就要引进一个新的关键词：**\_\_attribute\_\_**

这个关键字的中文意思是**属性**，这个关键词属于拓展语法，功能呢非常强大，有兴趣的自行搜索一下，这里我们就靠他来将变量输出到固定段。

先做一些宏定义和必要的结构体定义：

```c
struct __lvgl_app_item
{
    const char *name;
    const char *text;
    const void *img;
    lv_event_cb_t cb;
};
#define SECTION(x)                  __attribute__((section(x)))

#define RT_USED                     __attribute__((used))
```

然后就是重头戏，导出：

```c
#define LVGL_APP_ITEM_EXPORT(text, img, cb)                                                       \
    const char __lvgl_app_item_##text##_##img##_name[] SECTION(".rodata.lvgl") = "__app_" #text;  \
    const char __lvgl_app_item_##text##_##img##_text[] SECTION(".rodata.lvgl") = #text;           \
                                                                                                  \
    const struct __lvgl_app_item __lvgl_app_item_##text##_##img##_obj SECTION(".rodata.lvgl") = { \
        __lvgl_app_item_##text##_##img##_name, __lvgl_app_item_##text##_##img##_text, img, cb};   \
    RT_USED const void *__lvgl_app_##text##_##img##_point SECTION("LVObjTab") = &__lvgl_app_item_##text##_##img##_obj;
```

可以说这个宏是非常复杂的了，